function [VelLineal, VelAngular] = getControllerOutput(ControllerType, Meta, PuckPosicion_Actual, PuckOrientacion_Actual, RadioPuck)
% GETCONTROLLEROUTPUT Función que retorna la velocidad lineal y angular de
% los E-Pucks de acuerdo al controlador deseado. 
% -------------------------------------------------------------------------
% Inputs:
%   - ControllerType: Tipo de controlador que se desea acoplar al E-Puck.
%     Según el tipo de controlador se pueden llegar a requerir inputs
%     adicionales.
%   - Meta: Matriz de 1x2. Punto que desea alcanzar actualmente el E-Puck. 
%   - PuckPosicion_Actual: Matriz de Nx2. Cuenta con la misma estructura
%     que en el caso de "PartPosicion_Actual" con la diferencia que N ahora
%     simboliza el número de robots.
%   - PuckOrientacion_Actual: Vector columna con N ángulos en radianes, uno
%     por cada E-Puck. Este consiste del ángulo que existe entre el eje X+
%     del plano y la línea de orientación de los pucks si nos desplazamos
%     en contra de las manecillas del reloj. 
%   - RadioPuck: Radio de isomorfismo de E-Puck (Si eso sonó a chino: Es
%     un ajuste que se hace porque no se puede suponer que el centro del
%     robot está en el centro como tal. Se supone que está adelante de él,
%     comúnmente en el radio del mismo). 
%
% Outputs:
%   - VelLineal: Vector columna con tantas filas como Pucks. Velocidad en
%     la dirección de la línea de orientación del Puck.
%   - VelAngular: Vector columna con tantas filas como Pucks. Velocidad
%     angular o tasa a la que cambia el ángulo de la línea de orientación
%     del Puck.
% -------------------------------------------------------------------------
%
% Opciones "ControllerType"
%   
%   - PID: Control PID con filtro "hard stops".    
%
%   - TUC-LQR: Control LQR diseñado utilizando la función lqr(A,B,Q,R) de 
%     Matlab donde A = [0 0; 0 0], B = [1 0; 0 1], R = B y Q = B*0.01.
%     Utilizando este controlador se observaron trayectorias casi rectas
%     hacia la meta. No ventajoso para espacios de búsqueda con obstáculos.
%     Parámetros adicionales: RadioCuerpoPuck
%
%   - TUC-LQI: Control LQI diseñado utilizando la función lqr(A,B,Q,R) de 
%     Matlab donde A = 0, B = I, C = I, Q = eye(4) y R = 2000 * eye(2). 
%     Las matrices resultantes K y Ki fueron 0.2127 * eye(2) y -0.0224 *
%     eye(2) respectivamente. Resultados casi idénticos a los del LQR, con
%     la diferencia que este presentaba velocidades más "suaves".
%     Parámetros adicionales: RadioCuerpoPuck, Posicion_GlobalBest
%
% -------------------------------------------------------------------------

% Variables que mantienen su valor entre diferentes llamadas a una función
persistent ErrorAcumulado

switch ControllerType
    % Controlador de Pose con Criterio de Estabilidad de Lyapunov
    case "Lyapunov"
        
        % Parámetros de controlador
        K_Rho = 0.1;
        K_Alpha = 0.5;
        
        % Rho_p: Distancia de todos los Pucks a la Meta
        [~,Rho_p] = dsearchn(Meta,PuckPosicion_Actual);
        
        % Error de posición
        ErrorPos = PuckPosicion_Actual - Meta;
        
        % Ángulo de línea entre meta y robot
        Theta_g = atan2(ErrorPos(:,2),ErrorPos(:,1));
        
        % Orientación actual del robot
        Theta_o = PuckOrientacion_Actual;
        
        % Error de orientación
        Alpha = - Theta_o + Theta_g;
        Alpha = atan2(sin(Alpha),cos(Alpha)) + pi;
        
        % Velocidades Lineal y Angular (Nadalini, pág. 31)
        VelLineal = K_Rho .* Rho_p .* cos(Alpha);
        VelAngular = (K_Rho .* sin(Alpha) .* cos(Alpha)) + K_Alpha .* Alpha;
        
        % Las 
        VelLineal = -VelLineal(Alpha <= -pi/2 || Alpha > pi/2)
    
    % Controlador por Regulador Lineal Cuadrático (LQR)
    case "LQR"
        
        % Se inicializa el error acumulado, en caso aún no tenga valor
        % alguno.
        if isempty(ErrorAcumulado)
            ErrorAcumulado = zeros(size(PuckPosicion_Actual));                             
        end
        
        % Error de posición entre robot y meta
        ErrorPos = PuckPosicion_Actual - Meta;
        
        % Controlador LQR
    	K = 0.1;              	% Parámetros de controlador (Nadalini, pág 82)
        U = -K * (ErrorPos);  	% Retroalimentación (Nadalini, pág 36)
        
        % Actualización de velocidades
        VelLineal = U(:,1).*cos(PuckOrientacion_Actual) + U(:,2).*sin(PuckOrientacion_Actual);
        VelAngular = (-U(:,1).*sin(PuckOrientacion_Actual) + U(:,2).*cos(PuckOrientacion_Actual)) / RadioPuck;
    
    % Controlador Lineal Cuadrático Integral
    case "LQI"

        % Se inicializa el error acumulado, en caso aún no tenga valor
        % alguno.
        if isempty(ErrorAcumulado)
            ErrorAcumulado = zeros(size(PuckPosicion_Actual));                             
        end
        
        % Parámetros de controlador (Nadalini, pág 85 y 86)
        SamplingTime = 0.032;
        Bp = 0.95;             	% Amortiguamiento de control proporcional
        Bi = 0.01;              % Amortiguamiento de control integral                      
        KLQR = -0.2127;         % Control
        KLQI = -0.0224;
        
        % Error de posición entre robot y meta
        ErrorPos = Meta - PuckPosicion_Actual;
        
        % Controlador LQI (u = -K*e - Ki * Ei)
        U = (-KLQR * (1 - Bp) * ErrorPos) - (KLQI * ErrorAcumulado);
        
        % Integración numérica de error entre posición actual y meta
        ErrorAcumulado = ErrorAcumulado + (ErrorPos * SamplingTime);
        
        % Frenado de intregrador para evitar oscilaciones en posiciones
        ErrorAcumulado = (1 - Bi) * ErrorAcumulado;
        
        % Mapeo de velocidades LQI a velocidades de robot por medio de
        % difeomorfismo.
        VelLineal = U(:,1).*cos(PuckOrientacion_Actual) + U(:,2).*sin(PuckOrientacion_Actual);
        VelAngular = (-U(:,1).*sin(PuckOrientacion_Actual) + U(:,2).*cos(PuckOrientacion_Actual)) / RadioPuck;

end

